### **Task 1:**

### **Q1: Differences Between TensorFlow and PyTorch**

| Feature | TensorFlow | PyTorch |
| ----- | ----- | ----- |
| Graph Type | Static computation graph (default) | Dynamic computation graph (eager execution) |
| Syntax Style | More abstract, uses sessions | Pythonic and intuitive |
| Debugging | Harder due to static graph | Easier with native Python debugging |
| Deployment | Strong production tools (e.g., TFX) | Easier for research and prototyping |

**When to choose:**

* **TensorFlow**: Ideal for production environments, mobile deployment, and scalable pipelines.  
* **PyTorch**: Preferred in research, rapid prototyping, and when flexibility is key.

### **Q2: Two Use Cases for Jupyter Notebooks in AI Development**

1. **Interactive Prototyping**: Quickly test and iterate on machine learning models with immediate feedback and visualizations.  
2. **Documentation & Collaboration**: Combine code, output, and markdown to create shareable notebooks for team reviews or educational purposes.

### **Q3: How spaCy Enhances NLP Tasks**

* **Efficiency**: spaCy uses optimized Cython code for fast processing of large text corpora.  
* **Advanced Features**: Offers built-in tokenization, named entity recognition (NER), part-of-speech tagging, and dependency parsing.  
* **Compared to basic string operations**: While Pythonâ€™s `split()` or `find()` can handle simple tasks, spaCy understands linguistic structure, enabling semantic analysis and contextual understanding.

## **2\. Comparative Analysis: Scikit-learn vs. TensorFlow**

| Aspect | Scikit-learn | TensorFlow |
| ----- | ----- | ----- |
| **Target Applications** | Classical ML (e.g., regression, SVM, clustering) | Deep learning (e.g., neural networks, CNNs, RNNs) |
| **Ease of Use** | Very beginner-friendly; simple API | Steeper learning curve; more complex setup |
| **Community Support** | Strong support for ML practitioners and educators | Massive global community, especially in deep learning and production AI |

